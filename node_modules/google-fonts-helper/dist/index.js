'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib = require('tslib');
var path = require('path');
var url = require('url');
var querystring = require('querystring');
var fsExtra = require('fs-extra');
var deepmerge = require('deepmerge');
var got = _interopDefault(require('got'));

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = o[Symbol.iterator]();
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function isValidDisplay(display) {
  return ['auto', 'block', 'swap', 'fallback', 'optional'].includes(display);
}
function convertFamiliesObject(families) {
  var result = {};
  families.forEach(function (family) {
    if (!family) {
      return;
    }

    if (!family.includes(':')) {
      result[family] = true;
      return;
    }

    var parts = family.split(':');

    if (!parts[1]) {
      return;
    }

    var values = {};

    var _parts$1$split = parts[1].split('@'),
        _parts$1$split2 = _slicedToArray(_parts$1$split, 2),
        styles = _parts$1$split2[0],
        weights = _parts$1$split2[1];

    styles.split(',').forEach(function (style, index) {
      values[style] = weights.split(';').map(function (weight) {
        if (/^\+?\d+$/.test(weight)) {
          return parseInt(weight);
        }

        var _weight$split = weight.split(','),
            _weight$split2 = _slicedToArray(_weight$split, 2),
            pos = _weight$split2[0],
            w = _weight$split2[1];

        if (parseInt(pos) === index && /^\+?\d+$/.test(w)) {
          return parseInt(w);
        }

        return 0;
      }).filter(function (v) {
        return v > 0;
      });
    });
    result[parts[0]] = values;
  });
  return result;
}
function convertFamiliesToArray(families) {
  var result = [];
  Object.entries(families).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        name = _ref2[0],
        values = _ref2[1];

    if (!name) return;

    if (Array.isArray(values) && values.length > 0) {
      result.push("".concat(name, ":wght@").concat(values.join(';')));
      return;
    }

    if (Object.keys(values).length > 0) {
      var styles = [];
      var weights = [];
      Object.entries(values).forEach(function (_ref3, index) {
        var _ref4 = _slicedToArray(_ref3, 2),
            style = _ref4[0],
            weight = _ref4[1];

        styles.push(style);
        (Array.isArray(weight) ? weight : [weight]).forEach(function (value) {
          if (Object.keys(values).length === 1 && style === 'wght') {
            weights.push(value);
          } else {
            weights.push("".concat(index, ",").concat(value));
          }
        });
      });
      result.push("".concat(name, ":").concat(styles.join(','), "@").concat(weights.join(';')));
      return;
    }

    if (values) {
      result.push(name);
    }
  });
  return result;
}
function parseFontsFromCss(content, fontsPath) {
  var fonts = [];
  var re = {
    face: /\s*(?:\/\*\s*(.*?)\s*\*\/)?[^@]*?@font-face\s*{(?:[^}]*?)}\s*/gi,
    family: /font-family\s*:\s*(?:'|")?([^;]*?)(?:'|")?\s*;/i,
    weight: /font-weight\s*:\s*([^;]*?)\s*;/i,
    url: /url\s*\(\s*(?:'|")?\s*([^]*?)\s*(?:'|")?\s*\)\s*?/gi
  };
  var i = 1;
  var match1;

  while ((match1 = re.face.exec(content)) !== null) {
    var _match = match1,
        _match2 = _slicedToArray(_match, 2),
        fontface = _match2[0],
        comment = _match2[1];

    var familyRegExpArray = re.family.exec(fontface);
    var family = familyRegExpArray ? familyRegExpArray[1] : '';
    var weightRegExpArray = re.weight.exec(fontface);
    var weight = weightRegExpArray ? weightRegExpArray[1] : '';
    var match2 = void 0;

    while ((match2 = re.url.exec(fontface)) !== null) {
      var _match3 = match2,
          _match4 = _slicedToArray(_match3, 2),
          forReplace = _match4[0],
          url = _match4[1];

      var urlPathname = new URL(url).pathname;
      var ext = path.extname(urlPathname);

      if (ext.length < 2) {
        continue;
      }

      var filename = path.basename(urlPathname, ext) || '';
      var newFilename = formatFontFileName('{_family}-{weight}-{comment}{i}.{ext}', {
        comment: comment || '',
        family: family,
        weight: weight || '',
        filename: filename,
        _family: family.replace(/\s+/g, '_'),
        ext: ext.replace(/^\./, '') || '',
        i: String(i++)
      }).replace(/\.$/, '');
      fonts.push({
        inputFont: url,
        outputFont: newFilename,
        inputText: forReplace,
        outputText: "url('".concat(path.join(fontsPath, newFilename), "')")
      });
    }
  }

  return fonts;
}

function formatFontFileName(template, values) {
  return Object.entries(values).filter(function (_ref5) {
    var _ref6 = _slicedToArray(_ref5, 1),
        key = _ref6[0];

    return /^[a-z0-9_-]+$/gi.test(key);
  }).map(function (_ref7) {
    var _ref8 = _slicedToArray(_ref7, 2),
        key = _ref8[0],
        value = _ref8[1];

    return [new RegExp("([^{]|^){".concat(key, "}([^}]|$)"), 'g'), "$1".concat(value, "$2")];
  }).reduce(function (str, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 2),
        regexp = _ref10[0],
        replacement = _ref10[1];

    return str.replace(regexp, String(replacement));
  }, template).replace(/({|}){2}/g, '$1');
}

var GoogleFontsHelper = /*#__PURE__*/function () {
  function GoogleFontsHelper() {
    var fonts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, GoogleFontsHelper);

    this.fonts = fonts;
  }

  _createClass(GoogleFontsHelper, [{
    key: "getFonts",
    value: function getFonts() {
      return this.fonts;
    }
  }, {
    key: "constructURL",
    value: function constructURL() {
      var _this$fonts = this.fonts,
          families = _this$fonts.families,
          display = _this$fonts.display,
          subsets = _this$fonts.subsets;
      var family = convertFamiliesToArray(families !== null && families !== void 0 ? families : {});

      if (family.length < 1) {
        return false;
      }

      var query = {
        family: family
      };

      if (display && isValidDisplay(display)) {
        query.display = display;
      }

      var subset = (Array.isArray(subsets) ? subsets : [subsets]).filter(Boolean);

      if (subset.length > 0) {
        query.subset = subset.join(',');
      }

      return querystring.unescape(url.format({
        protocol: 'https',
        hostname: 'fonts.googleapis.com',
        pathname: 'css2',
        query: query
      }));
    }
  }, {
    key: "merge",
    value: function merge() {
      var newFonts = [this.fonts];

      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }

      values.forEach(function (value) {
        newFonts.push(value instanceof GoogleFontsHelper ? value.getFonts() : value);
      });
      this.fonts = deepmerge.all(newFonts);
    }
  }], [{
    key: "isValidURL",
    value: function isValidURL(url) {
      return /fonts.googleapis.com/.test(url);
    }
  }, {
    key: "parse",
    value: function parse(url) {
      if (!GoogleFontsHelper.isValidURL(url)) {
        return new GoogleFontsHelper();
      }

      var _URL = new URL(url),
          searchParams = _URL.searchParams;

      if (!searchParams.has('family')) {
        return new GoogleFontsHelper();
      }

      var result = {};
      var families = convertFamiliesObject(searchParams.getAll('family'));

      if (Object.keys(families).length < 1) {
        return new GoogleFontsHelper();
      }

      result.families = families;
      var display = searchParams.get('display');

      if (display && isValidDisplay(display)) {
        result.display = display;
      }

      var subsets = searchParams.get('subset');

      if (subsets) {
        result.subsets = subsets.split(',');
      }

      return new GoogleFontsHelper(result);
    }
  }, {
    key: "download",
    value: function download(url, options) {
      var _a;

      return tslib.__awaiter(this, void 0, void 0, function* () {
        if (!GoogleFontsHelper.isValidURL(url)) {
          throw new Error('Invalid Google Fonts URL');
        }

        var config = Object.assign({
          base64: false,
          overwriting: false,
          outputDir: './',
          stylePath: 'fonts.css',
          fontsDir: 'fonts',
          fontsPath: './fonts'
        }, options);
        var stylePath = path.resolve(config.outputDir, config.stylePath);
        var fontsDir = path.resolve(config.outputDir, config.fontsDir);

        if (!config.overwriting && fsExtra.pathExistsSync(stylePath)) {
          return;
        }

        var headers = {
          'user-agent': ['Mozilla/5.0 (Windows NT 10.0; Win64; x64)', 'AppleWebKit/537.36 (KHTML, like Gecko)', 'Chrome/80.0.3987.132 Safari/537.36'].join(' ')
        };

        var _yield$got = yield got(url, {
          headers: headers
        }),
            css = _yield$got.body;

        var fonts = parseFontsFromCss(css, config.fontsPath);

        var _iterator = _createForOfIteratorHelper(fonts),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var font = _step.value;
            var response = got(font.inputFont);
            var buffer = yield response.buffer();

            if (config.base64) {
              var mime = (_a = (yield response).headers['content-type']) !== null && _a !== void 0 ? _a : 'font/woff2';
              var content = buffer.toString('base64');
              css = css.replace(font.inputText, "url('data:".concat(mime, ";base64,").concat(content, "')"));
            } else {
              var fontPath = path.resolve(fontsDir, font.outputFont);
              yield fsExtra.outputFile(fontPath, buffer);
              css = css.replace(font.inputText, font.outputText);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        yield fsExtra.outputFile(stylePath, css);
      });
    }
  }]);

  return GoogleFontsHelper;
}();

module.exports = GoogleFontsHelper;
